\chapter{base/} \label{chap:base}

本章では，AzLibの土台とも言えるbaseディレクトリについて説明します．
このディレクトリでは，AzLibで採用されている様々な開発技術を実装しています．
まずはじめに，実装されているそれらの機能について概要を説明します．
AzLibを利用するだけであれば，この概要にだけ目を通しておけば十分でしょう．
それから，それらの技術を実装している関数群の細かい使い方を説明します．


\section{実装している機能の概要}
AzLibが実装している機能は，以下のものがあります．
\begin{itemize}
	\item エラー処理機能
	\item ログ出力機能
	\item メモリ管理機能
\end{itemize}

エラー処理機能は，プログラムがこちらの意図しない動作をしそうなときに，そのことを
知らせて強制終了するように処理する機能です．
たとえば，なんらかの数値を $0$ で割るような計算をしそうになったら，実行を途中で
止めなければなりません．
管理下にないメモリにアクセスしそうになったときも，未然に止めなければなりません．

ログ出力機能は，実行したプログラムが具体的にどのような計算の過程を経て最後の
結果にたどり着いたのかを自動的に出力する機能です．
ログファイルに限らず，実行途中の段階でも端末上に実行の過程を表示することで，
計算がちゃんと行われているかを即座に知ることができます．

メモリ管理機能は，プログラムが利用するメモリ領域を管理する機能です．
第\ref{chap:abstract}章でも少し説明しましたが，最適化のプログラムは精度を上げる
ために膨大なメモリを必要とします．
いわゆる「メモリの動的確保」を的確に，無駄なく行わなければなりません．
そのために，まずはじめに使用するメモリの合計量を宣言して確保しておき，その中から
必要なメモリを利用して，最後にすべて解放するようにします．

それぞれの機能の簡単な使い方について，次の節から説明していきます．
いくつかの部分で，具体例としてAzLib内のソースコードを使います．


\section{エラー処理機能の使い方}
AzLibでは，\textbf{RC型}（アールシーがた）と呼ばれる独自の変数型を用いて，エラー
処理機能を実装しています．
ここでは，その簡単な使い方を説明します．

\subsection{RC型} \label{subsec:RC-type}
AzLibの関数の多くは，RC型で定義されています．
RCはReturn Codeの略で，その関数が正常に実行されたかどうかを返り値とします．
返り値の種類を表\ref{tb:rc_pattern}に示します．
\begin{table}
\caption{エラーの分類} \label{tb:rc_pattern}
\centering
\begin{tabular}{ll}
\toprule
エラーの種類 & RC \\
\midrule
エラーなし & \texttt{NORMAL\_RC} \\
途中で処理を終了させる場合など & \texttt{END\_RC} \\
switch文の失敗など & \texttt{IMPLEMENT\_ERROR\_RC} \\
ファイルの読み込みの失敗など & \texttt{READ\_ERROR\_RC} \\
ファイルの書き込みの失敗など & \texttt{WRITE\_ERROR\_RC} \\
変換の失敗など & \texttt{CONVERT\_ERROR\_RC} \\
ポインタが\texttt{NULL}値であるなど & \texttt{NULL\_ERROR\_RC} \\
配列の動的確保の失敗など & \texttt{ALLOC\_ERROR\_RC} \\
ファイルオープンの失敗など & \texttt{OPEN\_ERROR\_RC} \\
ファイルクローズの失敗など & \texttt{CLOSE\_ERROR\_RC} \\
探索の失敗など & \texttt{SEEK\_ERROR\_RC} \\
データのフラッシュの失敗など & \texttt{FLUSH\_ERROR\_RC} \\
関数の引数が不適切であるなど & \texttt{ARG\_ERROR\_RC} \\
数値計算の失敗など & \texttt{CAL\_ERROR\_RC} \\
データのオーバーフローなど & \texttt{OVERFLOW\_ERROR\_RC} \\
データのアンダーフローなど & \texttt{UNDERFLOW\_ERROR\_RC} \\
$0$ が入ってはいけないときなど & \texttt{ZERO\_ERROR\_RC} \\
負の値が入ってはいけないときなど & \texttt{NEGATIVE\_ERROR\_RC} \\
 & \texttt{SUBMIT\_ERROR\_RC} \\
 & \texttt{OVERRUN\_ERROR\_RC} \\
 & \texttt{IGNORE\_ERROR\_RC} \\
いずれにもあてはまらない場合など & \texttt{UNKNOWN\_ERROR\_RC} \\
エラーとも呼びがたい場合など？ & \texttt{SPECIAL\_RC} \\
\bottomrule
\end{tabular}
\end{table}
数が多いので，眺める程度の理解で大丈夫です．
また，使い分けに関して厳密なルールはないので，適当に使い分ければ大丈夫です．
C言語ではvoid型以外の関数の返り値は $1$ つなので，他に値を返したい場合は
ポインタを使うことになります．

RC型の関数を呼ぶときは，専用のマクロを使います．
もしその関数が正常に実行されなかったことを表す値が返却されたときには，そのことを
表示し，その時点でプログラムを強制終了します．

\subsection{\texttt{RC\_TRY\_MAIN}マクロ}
main関数でRC型の関数を使うときは，\verb|RC_TRY_MAIN|マクロを用います．
たとえば，第\ref{chap:abstract}章で見た剛性最大化プログラムのソースコード
trac\_method.cを見てみましょう．
94行目の\verb|set_log_level()|で，ログの出力レベルを設定しています．
このとき，\verb|RC_TRY_MAIN|マクロを使って関数を呼んでいます．
そこから下でも，ログの出力先の設定や使用するメモリの上限値の設定など，数多くの
処理を行う関数がRC型で定義されており，\verb|RC_TRY_MAIN|マクロを使って実行して
います．

\subsection{\texttt{RC\_TRY}マクロ}
main関数以外の関数でRC型の関数を使うときは，\verb|RC_TRY|マクロを用います．
たとえば，mathematicsディレクトリのlu.cを見てみましょう．
25行目から，LU分解で連立 $1$ 次方程式を解く\verb|lu_solve()|という関数が定義
されています．
33行目で，RC型の\verb|allocate2D()|という関数が使われています．
このとき，\verb|RC_TRY|マクロを使って関数を呼んでいます．

\subsection{その他の主要なマクロ}
基本的に使うのはこの $2$ つのマクロですが，その他の主要なマクロをいくつか説明して
おきます．

ある変数がNULLのときに，そのことを表示して関数を終了させるときは，
\verb|RC_NULL_CHK|マクロを用います．
たとえば，先ほどの\verb|lu_solve()|の34行目で使われています．
\verb|index|の値が\verb|NULL|であるということは，動的確保が失敗しているという
ことを表します．
そのため，エラーとして関数を強制終了させなければなりません．

ある変数が $0$ より小さいときに，そのことを表示して関数を終了させるときは，
\verb|RC_NEG_CHK|マクロを用います．
エラー時に負値を返すような関数と組み合わせて使うと効果的です．

ある変数が $0$ 以下であるときに，そのことを表示して関数を終了させるときは，
\verb|RC_NEG_ZERO_CHK|マクロを用います．
配列の大きさが不適切な値でないかを検証するときなどに使います．

この他にもいくつかマクロが用意されています．


\section{ログ出力機能の使い方} \label{sec:log-output-utl}
ここでは，AzLibで実装されているログ出力機能について説明します．

\subsection{ログレベル}
AzLibでは，ログとして出力する情報の量をログレベルで調節します．
ログレベルは $1$ から $5$ までの $5$ 段階があります．
数字が大きいほど，出力する情報の量が多くなります．

ログレベルの設定は，main関数で\verb|set_log_lebel()|関数を呼んで行います．
trac\_method.cでは，94行目でログの出力レベルを設定しています．

\subsection{ログの出力先}
AzLibではログの出力先を，標準出力（stdout）や標準エラー出力（stderr），
任意のファイルなどに設定することができます．
ログの出力先は， $0$ 番から $4$ 番までの $5$ つを設定することができます．

ログの出力先の設定は，main関数で\verb|set_log_file()|関数を呼んで行います．
trac\_method.cでは，$98$ 行目，$99$ 行目でログ $0$ を標準エラー出力，ログ $1$ を
ファイルに設定しています．
出力先にファイルを設定する場合は，\verb|fopen()|や\verb|rc_fopen()|でファイル
ポインタを取得しておく必要があります．

設定したログの出力先のポインタは，\verb|get_log_file()|で取得することができます．
\verb|fprintf()|と組み合わせて使うことで，出力先を選んでログを出力することが
できます．


\section{メモリ管理機能の使い方}
ここでは，AzLibで実装されているメモリ管理機能について説明します．
C言語における「配列の動的確保」を利用していますので，知らなければある程度の予習
をしてから先に進むとよいでしょう．
設計思想については後述することにして，まずは使い方を簡単に説明します．

\subsection{メモリ空間の初期化と終了処理}
プログラムでは，行列やベクトルは配列変数で表現します．
有限要素解析では，大きいものであれば数百万規模の要素を持つ行列やベクトルを用いる
ので，配列を動的確保して使います．

動的確保するとは言っても，使えるメモリの大きさにはもちろん限界があります．
そこで，まずはじめに「だいたいこれぐらいのメモリを使います」というのをプログラム
の中で宣言しておきます．
その宣言が，\verb|mm_init()|という関数です．
\verb|trac_method.c| では，$102$ 行目で使用するメモリの上限値を 
$256 \ \mathrm{MB}$ に設定しています．
AzLibでは，配列の動的確保に使う関数がいくつか用意されています．
たとえば，実行列（\verb|double|型 $2$ 次元配列）の確保には\verb|allocate2D()|とい
う関数を使います．
AzLibで用意されている配列の動的確保の関数は，\verb|mm_init()|で確保した領域の中か
ら確保を行います．

動的確保では，確保した領域は最後に解放しなければなりません．
\verb|mm_init()| で確保した領域は，\verb|mm_terminate()| で解放します．
\verb|trac_method.c| では $169$ 行目，解析終了後に解放しています．

\subsection{確保したメモリ空間の利用}
\verb|mm_init()|で確保したメモリ空間から動的確保を行うときは，\verb|mm_alloc()|と
いう関数を使います．
AzLibで用意されている動的確保の関数は，この関数を使っています．
用意されてない変数型の配列の動的確保を行うときは，この関数を直接使うことになりま
す．

\verb|mm_alloc()|で確保した領域の解放には，\verb|mm_free()|という関数を使います．
動的確保した領域の解放に使うAzLibの関数はこの関数を使っています．
確保のときと同様に，用意されてない変数型の配列の解放を行うときは，この関数を直接
使うことになります．


\section{IDC共用体}


\section{関数の説明}
baseディレクトリの各ファイルを簡単に説明します．
関数の説明はソースコードを見ましょう．

\begin{itemize}

\item base.h：
baseディレクトリ全体のヘッダファイルです．

\item bin\_io.c/h：
バイナリファイルのI/Oを行う関数群です．

\item data\_model.c/h：
各データ型のサイズを出力する関数群です．

\item idc.c：
IDC共用体の関数群です．

\item list.c/h：

\item log\_printf.c：
ログの出力を行うための関数群です．

\item macros.h：
プログラムを書くときに用いる便利なマクロです．

\item mail\_utl.c/h：

\item memory\_manager.c/h：
メモリ管理に関する関数群です．
メモリサイズの単位はByteです．

\item messages.h：
\verb|log_printf.c| の関数で用いるエラーメッセージおよびワーニングメッセージを
定義しています．

\item rc.c/h：

\item scratch\_io.c/h：
スクラッチファイルの入出力を行う関数群です．

\item string\_utl.c/h：
文字列の操作を行う関数群です．

\item time\_utl.c/h：
タイムスタンプの出力および実行時間の取得を行う関数群です．

\item wrapper\_64.c/h：
64ビット整数型の処理を行う関数群です．

\end{itemize}


